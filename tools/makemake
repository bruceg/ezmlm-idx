#!/usr/bin/python3

import os, re, sys
from collections import defaultdict

re_include = re.compile('^\s*#include\s+"([^"]+)"\s*$', re.MULTILINE)

errors = False
SOURCES = set(['SOURCES','TARGETS','Makefile'])
TARGETS = dict()

def c(*args):
    print(' '.join(args))

def error(*args):
    print('{}: Error: {}'.format(sys.argv[0], ' '.join(args)))
    global errors
    errors = True

def split(filename):
    if '.' in filename:
        return filename.rsplit('.', 1)
    return filename,None

class Target:

    def __init__(self, target, parent=None):
        self.target = target
        self.deps = []
        self.commands = []
        self.parent = parent

    def dependon(self, *args):
        self.deps.extend(args)
        for dep in args:
            target(dep, self)

    def formake(self, cmd, *args, **kw):
        d = self.__dict__.copy()
        base,ext = split(self.target)
        d['base'] = base
        d['ext'] = ext
        d.update(kw)
        self.commands.append(cmd.format(*args, **d))

    def dependcc(self, source):
        self.dependon(source)
        dirname = os.path.dirname(source)
        if dirname:
            dirname += '/'
        if os.path.exists(source):
            for match in re_include.findall(open(source).read()):
                if '/' not in match:
                    try:
                        self.dependcc(dirname + match)
                    except NoSuchTarget:
                        pass
                    else:
                        continue
                self.dependcc(match)

    def dependx(self, source, command, *deps):
        libs = []
        libscat = []
        dashl = []
        objs = []
        for line in open(source):
            line = line.strip()
            if line.endswith('.lib'):
                libs.append(line)
                libscat.append('`cat {}`'.format(line))
            elif line.startswith('-l'):
                dashl.append(line)
                baselib = 'lib' + line[2:]
                if os.path.exists(baselib+'=l'):
                    libs.append(baselib+'.a')
            else:
                objs.append(line)
        self.dependon(command, *list(deps) + objs + libs)
        self.formake('./{} {} {}'.format(command, self.target, ' '.join(objs + dashl + libscat)))

    def choose(self, modes, tryfn):
        self.dependon('choose')
        if 'c' in modes: self.dependon('compile')
        if 'l' in modes: self.dependon('load')
        self.dependon(tryfn+'.c', self.target+'1', self.target+'2')
        self.formake('./choose {modes} {tryfn} {target}1 {target}2 > {target}', modes=modes, tryfn=tryfn)

class NoSuchTarget(Exception):
    pass

def runit(t, filename, **kw):
    global_vars = dict([ (name,getattr(t,name)) for name in dir(t) if not name.startswith('_') ])
    global_vars.update({
        'c': c,
        'error': error,
        'exists': os.path.exists,
        'listdir': os.listdir,
        })
    with open(filename) as f:
        code = compile(f.read(), filename, 'exec')
        return exec(code, global_vars, kw)

def target(name, parent=None):
    if os.path.exists(name) and not os.path.exists(name+'.do'):
        SOURCES.add(name)
    elif name in TARGETS or name in SOURCES:
        return
    else:
        target = Target(name, parent)
        TARGETS[name] = target
        base,ext = split(name)
        for dofile in [ name+'.do', 'default.{}.do'.format(ext), 'default.do' ]:
            if os.path.exists(dofile):
                runit(target, dofile, base=base, ext=ext, target=name)
                break
        if not target.deps and not target.commands:
            raise NoSuchTarget(target)

try:
    for line in open('TARGETS'):
        line = line.rstrip()
        try:
            os.unlink(line)
        except:
            pass
except FileNotFoundError:
    pass

print('Calculating targets...')
try:
    target('clean')
    target('targets')
except NoSuchTarget as e:
    target = e.args[0]
    print("No such target: {}".format(target.target))
    while target.parent:
        target = target.parent
        print("  ...from {}".format(target.target))
    sys.exit(1)

print('Building Makefile...')

makefile = open('Makefile', 'w')
print("""# This file is automatically generated, do not edit.
SHELL=/bin/sh
default: it""", file=makefile)

for target in sorted(TARGETS):
    target = TARGETS[target]
    print("", file=makefile)
    print("{}: \\\n{}".format(target.target, ' '.join(target.deps)), file=makefile)
    for line in target.commands:
        print('\t'+line, file=makefile)

def writelines(filename, lines):
    open(filename, 'w').write(''.join([ line + '\n' for line in lines ]))

writelines('SOURCES', SOURCES)
writelines('TARGETS', sorted(set(TARGETS.keys())))

print('done.')
